{
  "name": "com.unity.properties",
  "displayName": "Properties",
  "version": "2.0.0-exp.13",
  "unity": "2021.3",
  "unityRelease": "0f1",
  "description": "Use Unity's Properties to instrument types and create visitation algorithms.",
  "keywords": [
    "properties",
    "unity"
  ],
  "dependencies": {
    "com.unity.test-framework.performance": "2.8.0-preview"
  },
  "_upm": {
    "changelog": "This new major version focuses on consistency and extensibility. As such, all the public APIs has been reviewed and refactored to make them easier to understand and use and harder to misuse. We are also exposing a lot of the internals so that users can create low-level visitors.\n\nThis release also marks a change in how we generate property bags for IL2CPP platforms. Previously, we were using IL Post Processors to generate property bags; we have now switched to using Source Generators. In order to ensure that the impact on compilation and domain reload are as minimal as possible, code generation now requires an assembly to be tagged with the `GeneratePropertyBagsForAssembly` attribute.\n\n### Changed\n* Updated minimum Unity version to `2021.3`.\n* Updated `com.unity.test-framework.performance` to version `2.8.0`.\n* Removed dependency on `com.unity.nuget.mono-cecil`.\n* Changed the property bag generation from IL Post Processors to Source Generators. Assemblies now have to opt-in code generation by tagging the assembly with the `[GeneraPropertyBagsForAssembly]` attribute.\n\n* ***Breaking change*** `PropertyBag` and `Property` have been refactored for consistency and to provide more extensibility.\n  * `IPropertyBag<T>.GetProperties` now returns a `PropertyCollection<T>` instead of an `IEnumerable<IProperty<T>>`. The `PropertyCollection<T>` struct can be used to enumerate properties with no allocations in common cases.\n  * Added a `IPropertyBag<T>.GetProperties` overload that does not require an instance. This overload can only support cached properties. \n  * Added `PropertyBag.GetPropertyBag(Type)` and `PropertyBag.GetPropertyBag<T>()` API methods.\n  * Added a `PropertyBag.Exists` method for checking if a property bag exists for a given type.\n  * Added a `PropertyBag.CreateInstance` method which allows type construction through an explicit delegate, property bag implementation or activator.\n  * `IProperty<T>.TrySetValue` has been renamed to `IProperty<T>.SetValue`.\n  * `IProperty.Visit<TValue>(PropertyVisitor, TValue)` has been removed. Use `PropertyContainer.Accept(IPropertyBagVisitor, TContainer)` instead.\n\n* ***Breaking change*** Visitors have been refactored for consistency and to provide more extensibility.\n  * Added all visitor interfaces to the public API (`IPropertyBagVisitor`, `IPropertyVisitor` etc). These can be used to write lower level and more specialized visitors.\n  * Added a `PropertyBag.AccepWithSpecializedVisitor` helper method to dispatch to the correct visitation overload.\n  * Visitation adapters (`IExclude` and `IVisit`) now pass a context object (respectively `ExcludeContext` and `VisitContext`) instead of the `IProperty`.\n  * `Unity.Properties.VisitStatus` has been removed. Visitation adapters now requires an explicit call to `ContinueVisitation` (equivalent of `VisitStatus.Unhandled`) or `ContinueVisitationWithoutAdapters` (equivalent of `VisitStatus.Handled`) in order continue visitation.\n\n* ***Breaking change*** The `PropertyContainer` has been refactored to increase consistency and user-friendliness.\n  * `PropertyContainer.Visit` has been renamed to `PropertyContainer.Accept` and the parameter order has changed.\n  * Added a `PropertyContainer.TryAccept` overload taking a `PropertyPath`.\n  * Added a `PropertyContainer.IsPathValid` overload taking a `string`.\n  * Added a `VisitParameters` parameter to all `PropertyContainer.Accept` overloads.\n  * `PropertyContainer.GetProperty(ref object, PropertyPath)` and `PropertyContainer.TryGetProperty(ref object, PropertyPath)` have been removed. The generic overload should now be used.\n  * `PropertyContainer.GetValue<T>(ref object, string)`, `PropertyContainer.GetValue<T>(ref object, PropertyPath)`, `PropertyContainer.TryGetValue<T>(ref object, string, out T)` and `PropertyContainer.TryGetValue<T>(ref object, PropertyPath, out T)` have been removed. The generic overload should now be used.\n  * `PropertyContainer.SetValue<T>(ref object, string)`, `PropertyContainer.SetValue<T>(ref object, PropertyPath, T)`, `PropertyContainer.TrySetValue<T>(ref object, string, T)` and `PropertyContainer.TrySetValue<T>(ref object, PropertyPath, T)` have been removed. The generic overload should now be used.\n  * `PropertyContainer.IsPathValid(ref object, PropertyPath)` has been removed. The generic overload should now be used.\n  * Fixed `PropertyContainer.IsPathValid` throwing an exception when a `null` value is visited on the given path.\n  * `VisitExceptionType` has been renamed to `VisitExceptionKind`\n  * `VisitErrorCode` has been renamed to `VisitReturnCode`.\n\n* ***Breaking change*** `TypeConversion` has been refactored to avoid stack overflows when trying to convert very large structs.\n  * `TypeConversion.Convert` and `TypeConversion.TryConvert` methods must now pass the source parameter as a `ref`.\n  * `TypeConversion.ConvertDelegate` has been renamed to `TypeConversion.TypeConverter` now passes the source parameters by `ref`.\n  * `TypeConversion` primitive converters now perform a direct C# cast instead of clamping.\n\n* ***Breaking change*** `PropertyPath` was heavily refactored and is now an immutable struct.\n  * `PropertyPath.PartsCount` has been renamed to `PropertyPath.Length`.\n  * `PropertyPath.Empty` has been renamed to `PropertyPath.IsEmpty`.\n  * `PropertyPath.PopPart` has been renamed to `PropertyPath.Pop` and was changed from an instance method to a static method.\n  * `PropertyPath.AppendPath` overloads has been renamed to `PropertyPath.Combine` and were changed from instance to static methods.\n  * `PropertyPath.AppendPart`, `PropertyPath.AppendName`, `PropertyPath.AppendIndex`, `PropertyPath.AppendKey` and `PropertyPath.AppendProperty` were changed from instance to static methods.\n  * `PropertyPath.Part` has been renamed to `PropertyPathPart`.\n  * `PropertyPath.PartType` has been renamed to `PropertyPathPartKind`.\n\n* ***Breaking change*** `TypeConstruction` has been merged into `Unity.Properties.TypeUtility` and is now partly available at runtime.\n  * `TypeConstruction.UnsetExplicitConstructionMethod` and `TypeConstruction.TryUnsetExplicitConstructionMethod` has been removed.\n  * `GetAllConstructableTypes` has been removed. It is now available through the `com.unity.properties.ui` package.\n  * `CanBeConstructedFromDerivedType` has been removed. It is now available through the `com.unity.properties.ui` package.\n  * Fixed type conversion issues for `Nullable` types.\n\n* ***Breaking change*** `TypeUtility` has been moved from `Unity.Properties.Editor` to `Unity.Properties` and is now available at runtime.\n* ***Breaking change*** The `GeneratePropertyBagsInEditorAttribute` has been removed.\n\n* ***Breaking change*** The `AOT` helpers have been removed in Unity 2022.1 and newer versions.\n\n### Added\n \n* Added a `PathVisitor` base class allowing to run the visitor at a specific `PropertyPath`.\n* Added a `ConcreteTypeVisitor` base class allowing to receive a strongly-typed callback for a given container instance.\n* Added a `TypeTraits` utility class.\n\n### Removed\n* Removed the global conversion between `Vector2` and `vector2Int`.\n* Removed the global conversion between `Vector3` and `vector3Int`.\n* Removed the `AnimationCurve` and `KeyFrame` types from the default property bags.\n* Removed internal usage of the `UNITY_DOTSRUNTIME` define.\n\n### Fixed\n* Fixed an issue where converting from `object` to a `UnityEngine.Object` would cause a stack overflow."
  },
  "upmCi": {
    "footprint": "2de7adca94194ab01be511af33cc276fa4a37c9b"
  },
  "repository": {
    "url": "https://github.cds.internal.unity3d.com/unity/com.unity.properties.git",
    "type": "git",
    "revision": "733b021f5e5b986dad4243f1a65993aec291f777"
  }
}
